"use strict";(self.webpackChunkwebsitev_2=self.webpackChunkwebsitev_2||[]).push([[5775],{35244:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>f,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var r=n(87462),o=(n(67294),n(3905));const a={title:"ADR: Preferred data fetching method"},s=void 0,i={unversionedId:"contributing/ADRs/front-end/preferred-data-fetching-method",id:"contributing/ADRs/front-end/preferred-data-fetching-method",title:"ADR: Preferred data fetching method",description:"Background",source:"@site/docs/contributing/ADRs/front-end/preferred-data-fetching-method.md",sourceDirName:"contributing/ADRs/front-end",slug:"/contributing/ADRs/front-end/preferred-data-fetching-method",permalink:"/contributing/ADRs/front-end/preferred-data-fetching-method",draft:!1,editUrl:"https://github.com/Unleash/unleash/edit/main/website/docs/contributing/ADRs/front-end/preferred-data-fetching-method.md",tags:[],version:"current",frontMatter:{title:"ADR: Preferred data fetching method"},sidebar:"documentation",previous:{title:"ADR: Preferred component props usage",permalink:"/contributing/ADRs/front-end/preferred-component-props-usage"},next:{title:"ADR: Preferred data mutation method",permalink:"/contributing/ADRs/front-end/preferred-data-mutation-method"}},d={},c=[{value:"Background",id:"background",level:2},{value:"Decision",id:"decision",level:2}],m={toc:c};function f(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"background"},"Background"),(0,o.kt)("p",null,"We have found a need to standardise how we fetch data from APIs, in order to reduce complexity and simplify the data fetching process."),(0,o.kt)("h2",{id:"decision"},"Decision"),(0,o.kt)("p",null,"We have decided to remove redux from our application and fetch all of our data via a third party library called ",(0,o.kt)("inlineCode",{parentName:"p"},"useSWR")," (SWR stands for stale-while-revalidate and is a common cache strategy)."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// Do:\n// useSegments.ts\n\nimport useSWR from 'swr';\nimport { useCallback } from 'react';\nimport { formatApiPath } from 'utils/formatPath';\nimport handleErrorResponses from '../httpErrorResponseHandler';\nimport { ISegment } from 'interfaces/segment';\nimport useUiConfig from 'hooks/api/getters/useUiConfig/useUiConfig';\nimport { IFlags } from 'interfaces/uiConfig';\n\nexport interface UseSegmentsOutput {\n    segments?: ISegment[];\n    refetchSegments: () => void;\n    loading: boolean;\n    error?: Error;\n}\n\nexport const useSegments = (strategyId?: string): UseSegmentsOutput => {\n    const { uiConfig } = useUiConfig();\n\n    const { data, error, mutate } = useSWR(\n        [strategyId, uiConfig.flags],\n        fetchSegments\n    );\n\n    const refetchSegments = useCallback(() => {\n        mutate().catch(console.warn);\n    }, [mutate]);\n\n    return {\n        segments: data,\n        refetchSegments,\n        loading: !error && !data,\n        error,\n    };\n};\n\nexport const fetchSegments = async (\n    strategyId?: string,\n    flags?: IFlags\n): Promise<ISegment[]> => {\n    if (!flags?.SE) {\n        return [];\n    }\n\n    return fetch(formatSegmentsPath(strategyId))\n        .then(handleErrorResponses('Segments'))\n        .then(res => res.json())\n        .then(res => res.segments);\n};\n\nconst formatSegmentsPath = (strategyId?: string): string => {\n    return strategyId\n        ? formatApiPath(`api/admin/segments/strategies/${strategyId}`)\n        : formatApiPath('api/admin/segments');\n};\n\n// Don't:\nconst MyComponent = () => {\n    useEffect(() => {\n        const getData = () => {\n            fetch(API_URL)\n                .then(res => res.json())\n                .then(setData);\n        };\n        getData();\n    }, []);\n};\n")))}f.isMDXComponent=!0}}]);