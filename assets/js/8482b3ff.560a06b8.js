"use strict";(self.webpackChunkwebsitev_2=self.webpackChunkwebsitev_2||[]).push([[1927],{69056:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>n,metadata:()=>r,toc:()=>u});var i=a(87462),o=(a(67294),a(3905));const n={title:"2. Never expose PII. Follow the principle of least privilege."},s=void 0,r={unversionedId:"topics/feature-flags/never-expose-pii",id:"topics/feature-flags/never-expose-pii",title:"2. Never expose PII. Follow the principle of least privilege.",description:"To keep things simple, you may be tempted to evaluate the feature flags in your Feature Flag Control Service. Don\u2019t. Your Feature Flag Control Service should only handle the configuration for your feature flags and pass this configuration down to SDKs connecting from your applications.",source:"@site/docs/topics/feature-flags/never-expose-pii.md",sourceDirName:"topics/feature-flags",slug:"/topics/feature-flags/never-expose-pii",permalink:"/topics/feature-flags/never-expose-pii",draft:!1,editUrl:"https://github.com/Unleash/unleash/edit/main/website/docs/topics/feature-flags/never-expose-pii.md",tags:[],version:"current",frontMatter:{title:"2. Never expose PII. Follow the principle of least privilege."},sidebar:"documentation",previous:{title:"1. Enable run-time control. Control flags dynamically, not using config files.",permalink:"/topics/feature-flags/runtime-control"},next:{title:"3. Evaluate flags as close to the user as possible. Reduce latency.",permalink:"/topics/feature-flags/evaluate-flags-close-to-user"}},l={},u=[],c={toc:u};function p(e){let{components:t,...a}=e;return(0,o.kt)("wrapper",(0,i.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"To keep things simple, you may be tempted to evaluate the feature flags in your Feature Flag Control Service. Don\u2019t. Your Feature Flag Control Service should only handle the configuration for your feature flags and pass this configuration down to SDKs connecting from your applications. "),(0,o.kt)("p",null,"The primary rationale behind this practice is that feature flags often require contextual data for accurate evaluation. This may include user IDs, email addresses, or geographical locations that influence whether a flag should be toggled on or off. Safeguarding this sensitive information from external exposure is paramount. This information may include Personally Identifiable Information (PII), which must  remain confined within the boundaries of your application, following the data security principle of least privilege (PoLP)."),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://github.com/Unleash/unleash/assets/87366358/6ca24aea-26fb-481d-92ff-a9af2729cb83",alt:"feature-flag-server-side-evaluation"})),(0,o.kt)("p",null,"For client-side applications where the code resides on the user's machine, such as in the browser or on mobile devices, you\u2019ll want to take a different approach. You can\u2019t evaluate on the client side because it raises significant security concerns by exposing potentially sensitive information such as API keys, flag data, and flag configurations. Placing these critical elements on the client side increases the risk of unauthorized access, tampering, or data breaches."),(0,o.kt)("p",null,"Instead of performing client-side evaluation, a more secure and maintainable approach is to conduct feature flag evaluation within a self-hosted environment. Doing so can safeguard sensitive elements like API keys and flag configurations from potential client-side exposure. This strategy involves a server-side evaluation of feature flags, where the server makes decisions based on user and application parameters and then securely passes down the evaluated results to the frontend without any configuration leaking. "),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://github.com/Unleash/unleash/assets/87366358/28240019-ea3c-4ae6-a6da-60ad9079dc54",alt:"feature-flag-architecture-client-side"})),(0,o.kt)("p",null,"Here\u2019s how you can architect your solution to minimize PII or configuration leakage: "),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Server-Side Components"),":")),(0,o.kt)("p",null,"In Principle 1, we proposed a set of architectural principles and components to set up a Feature Flag Control Service. The same architecture patterns apply here, with additional suggestions for achieving local evaluation. Refer to Principle 1 for patterns to set up a feature flagging service."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Feature Flag Evaluation Service"),": If you need to use feature flags on the client side, where code is delivered to users' devices, you\u2019ll need an evaluation server that can evaluate feature flags and pass evaluated results down to the SDK in the client application."),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"SDKs"),":")),(0,o.kt)("p",null,"SDKs will make it more comfortable to work with feature flags. Depending on the context of your infrastructure, you need different types of SDKs to talk to your feature flagging service. For the server side, you\u2019ll need SDKs that can talk directly to the feature flagging service and fetch the configuration."),(0,o.kt)("p",null,"The server-side SDKs should implement logic to evaluate feature flags based on the configuration received from the Feature Flag Control Service and the application-specific context. Local evaluation ensures that decisions are made quickly without relying on network roundtrips."),(0,o.kt)("p",null,"For client-side feature flags, you\u2019ll need a different type of SDK. These SDKs will send the context to the Feature Flag Evaluation Service and receive the evaluated results. These results should be stored in memory and used when doing a feature flag lookup in the client-side application. By keeping the evaluated results for a specific context in memory in the client-side application, you avoid network roundtrips every time your application needs to check the status of a feature flag. It achieves the same level of performance as a server-side SDK, but the content stored in memory is different and limited to evaluated results on the client."),(0,o.kt)("p",null,"The benefits of this approach include:"),(0,o.kt)("p",null," ",(0,o.kt)("strong",{parentName:"p"},"Privacy Protection"),":"),(0,o.kt)("p",null,"   a. ",(0,o.kt)("strong",{parentName:"p"},"Data Minimization"),": By evaluating feature flags in this way, you minimize the amount of data that needs to be sent to the Feature Flag Control Service. This can be crucial for protecting user privacy, as less user-specific data is transmitted over the network."),(0,o.kt)("p",null,"   b. ",(0,o.kt)("strong",{parentName:"p"},"Reduced Data Exposure"),":  Sensitive information about your users or application's behavior is less likely to be exposed to potential security threats. Data breaches or leaks can be mitigated by limiting the transmission of sensitive data."))}p.isMDXComponent=!0}}]);