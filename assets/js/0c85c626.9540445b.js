"use strict";(self.webpackChunkwebsitev_2=self.webpackChunkwebsitev_2||[]).push([[61134],{66224:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>l,contentTitle:()=>o,default:()=>f,frontMatter:()=>i,metadata:()=>r,toc:()=>u});var n=t(87462),s=(t(67294),t(3905));const i={title:"8. Use unique names across all applications. Enforce naming conventions."},o=void 0,r={unversionedId:"topics/feature-flags/unique-names",id:"topics/feature-flags/unique-names",title:"8. Use unique names across all applications. Enforce naming conventions.",description:"All flags served by the same Feature Flag Control service should have unique names across the entire cluster to avoid inconsistencies and errors.",source:"@site/docs/topics/feature-flags/unique-names.md",sourceDirName:"topics/feature-flags",slug:"/topics/feature-flags/unique-names",permalink:"/topics/feature-flags/unique-names",draft:!1,editUrl:"https://github.com/Unleash/unleash/edit/main/website/docs/topics/feature-flags/unique-names.md",tags:[],version:"current",frontMatter:{title:"8. Use unique names across all applications. Enforce naming conventions."},sidebar:"documentation",previous:{title:"7. Make feature flags short-lived. Do not confuse flags with application configuration.",permalink:"/topics/feature-flags/short-lived-feature-flags"},next:{title:"9. Choose open by default. Democratize feature flag access.",permalink:"/topics/feature-flags/democratize-feature-flag-access"}},l={},u=[],c={toc:u};function f(e){let{components:a,...t}=e;return(0,s.kt)("wrapper",(0,n.Z)({},c,t,{components:a,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"All flags served by the same Feature Flag Control service should have unique names across the entire cluster to avoid inconsistencies and errors. "),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Avoid zombies:")," Uniqueness should be controlled using a global list of feature flag names. This prevents the reuse of old flag names to protect new features. Using old names can lead to accidental exposure of old features, still protected with the same feature flag name. "),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Naming convention enforcement: "),"Ideally, unique names are enforced at creation time. In a large organization, it is impossible for all developers to know all flags used. Enforcing a naming convention makes naming easier, ensures consistency, and provides an easy way to check for uniqueness.")),(0,s.kt)("p",null,"Unique naming has the following advantages:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Flexibility over time: "),"Large enterprise systems are not static. Over time, monoliths are split into microservices, microservices are merged into larger microservices, and applications change responsibility. This means that the way flags are grouped will change over time, and a unique name for the entire organization ensures that you keep the option to reorganize your flags to match the changing needs of your organization."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Prevent conflicts"),": If two applications use the same Feature Flag name it can be impossible to know which flag is controlling which applications. This can lead to accidentally flipping the wrong flag, even if they are separated into different namespaces (projects, workspaces etc). "),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Easier to manage: "),"It's easier to know what a flag is used for and where it is being used when it has a unique name. E.g. It will be easier to search across multiple code bases to find references for a feature flag when it has a unique identifier across the entire organization. "),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Enables collaboration:")," When a feature flag has a unique name in the organization, it simplifies collaboration across teams, products and applications. It ensures that we all talk about the same feature.")))}f.isMDXComponent=!0}}]);