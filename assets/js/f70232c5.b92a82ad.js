"use strict";(self.webpackChunkwebsitev_2=self.webpackChunkwebsitev_2||[]).push([[83694],{62782:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>r,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>u});var o=a(87462),n=(a(67294),a(3905));const i={title:"7. Make feature flags short-lived. Do not confuse flags with application configuration."},l=void 0,s={unversionedId:"topics/feature-flags/short-lived-feature-flags",id:"topics/feature-flags/short-lived-feature-flags",title:"7. Make feature flags short-lived. Do not confuse flags with application configuration.",description:"Feature flags have a lifecycle shorter than an application lifecycle. The most common use case for feature flags is to protect new functionality. That means that when the roll-out of new functionality is complete, the feature flag should be removed from the code and archived. If there were old code paths that the new functionality replaces, those should also be cleaned up and removed.",source:"@site/docs/topics/feature-flags/short-lived-feature-flags.md",sourceDirName:"topics/feature-flags",slug:"/topics/feature-flags/short-lived-feature-flags",permalink:"/topics/feature-flags/short-lived-feature-flags",draft:!1,editUrl:"https://github.com/Unleash/unleash/edit/main/website/docs/topics/feature-flags/short-lived-feature-flags.md",tags:[],version:"current",frontMatter:{title:"7. Make feature flags short-lived. Do not confuse flags with application configuration."},sidebar:"documentation",previous:{title:"6. Design for failure. Favor availability over consistency.",permalink:"/topics/feature-flags/availability-over-consistency"},next:{title:"8. Use unique names across all applications. Enforce naming conventions.",permalink:"/topics/feature-flags/unique-names"}},r={},u=[],f={toc:u};function c(e){let{components:t,...a}=e;return(0,n.kt)("wrapper",(0,o.Z)({},f,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("p",null,"Feature flags have a lifecycle shorter than an application lifecycle. The most common use case for feature flags is to protect new functionality. That means that when the roll-out of new functionality is complete, the feature flag should be removed from the code and archived. If there were old code paths that the new functionality replaces, those should also be cleaned up and removed."),(0,n.kt)("p",null,"Feature flags should not be used for static application configuration. Application configuration is expected to be consistent, long-lived, and read when launching an application. Using feature flags to configure an application can lead to inconsistencies between different instances of the same application. Feature flags, on the other hand, are designed to be short-lived, dynamic, and changed at runtime. They are expected to be read and updated at runtime and favor availability over consistency."),(0,n.kt)("p",null,"To succeed with feature flags in a large organization, you should:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Use flag expiration dates"),": By setting expiration dates for your feature flags, you make it easier to keep track of old feature flags that are no longer needed. A proper feature flag solution will inform you about potentially expired flags.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Treat feature flags like technical debt."),": You must plan to clean up old feature branches in sprint or project planning, the same way you plan to clean up technical debt in your code. Feature flags add complexity to your code. You\u2019ll need to know what code paths the feature flag enables, and while the feature flag lives, the context of it needs to be maintained and known within the organization. If you don\u2019t clean up feature flags, eventually, you may lose the context surrounding it if enough time passes and/or personnel changes happen. As time passes, you will find it hard to remove flags, or to operate them effectively.    ")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Archive old flags"),": Feature flags that are no longer in use should be archived after their usage has been removed from the codebase. The archive serves as an important audit log of feature flags that are no longer in use, and allows you to revive them if you need to install an older version of your application."))),(0,n.kt)("p",null,"There are valid exceptions to short-lived feature flags. In general, you should try to limit the amount of long-lived feature flags. Some examples include: "),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Kill-switches - these work like an inverted feature flag and are used to gracefully disable part of a system with known weak spots. "),(0,n.kt)("li",{parentName:"ul"},"Internal flags used to enable additional debugging, tracing, and metrics at runtime, which are too costly to run all the time. These can be enabled by software engineers while debugging issues.")))}c.isMDXComponent=!0}}]);